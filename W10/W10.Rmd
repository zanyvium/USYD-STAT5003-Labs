---
title: "W10 STAT5003 RMD"
author: "Victor Z. Nygaard, vnyg7406"
header-includes:
   - \usepackage[utf8]{inputenc}
   - \usepackage{verbatim}
   - \usepackage[language]{babel}
   - \usepackage[encoding]{inputenc}
   - \usepackage{hyperref}
   - \usepackage{amsmath}
   - \usepackage{mathtools}
   - \usepackage{amssymb}
   - \usepackage{mathtools}
   - \usepackage{nicefrac}
   - \usepackage{fullpage}
   - \usepackage{stmaryrd}
   - \usepackage{aligned-overset}
   - \usepackage{pdfpages}
date: "Last compiled on `r format(Sys.time(), '%d. %B, %Y')`"
# Hvordan får  vi den til at printe February i stedet for februar??????
output: html_document
---

------------------------------------------------------------------------

```{=html}
<!-- RMD tips:
1. CTRL+SHIFT+C RMD-comments-out the selected lines, with in a standard HTML comment-out format. 

2. CTRL+ALT+I inserts a new r codechunck

3. Pressing CTRL+SHIFT+ENTER when over a code chunck gives you a preview of the results of the chunck

4. CTRL+SHIFT+K gives you a preview of the entire resulting HTML file.

5. Note the different results of '#HS 1' and 
'# HS 1' (without the '') in the output

6. It is possible to compile regular R-scripts into Rmd files - this is done by pressing CTRL+SHIFT+K while attending any R-script. <<<- Though this apparently doesn't work for HS Problems.R for some reason!?!?!? ->>>

7. Selective use of the echo=c(...) option within code chuncks allows assignment of a variable, to show the assignment in the knitted document, and showing the value of the assignment seamlessly as well - see HS2.3

8. It is possible to include results of R-analysis such as summary statistics in LaTeX-equations in RMD, see HS2.3

9. Adding fig.align="center" to a code chunk centers any figures generated by the chunck.

9.1 note that properties of codechunks seem casesensitive; fig.align="center" centers a figure, but fig.align="Center" (with capital C) doesn't

10. A new subtitle needs a blank line before itself: 
'works:

#### HS 7
'

'doesn't:
blablabla
#### HS 7
'

'doesn't either:
<!-- blablabla ->
#### HS 7
'
11. Pressing F7 when marking, or hovering over a word will spellcheck the word

12. CTRL + - (minus) zooms out, CTRL + + (plus) zooms in

13. CTRL + D Deletes the current line, or current selection of lines

14. THE FOLLOWING SOURCE EDITOR FOLDING METHODS:
14.1 Collapse current fold: ALT + L
14.1.1: Expand current fold: SHIFT + ALT + L
14.2 Collapse "all" subfolds: ALT + O <- !?!! Note that this leaves a small letter 'o' in the text !!?!
14.2.1 Expand "all" subfolds: SHIFT + ALT + O
14.3 Collapse all other folds: ALT + 0 (zero)

15. SHIFT + ALT + J allows you to jump to specific parts of the document

16. Writing a new line with '...' will cause all previous output to be hidden in the knittet document

17. Writing (q<-5) around R code, will both assign and print the code upon assignment 

18. Note that 'attach' only has the scope of the current R-chunck.

19. One way to get pdf printout is to compile a html-printout, and then, in-browser, 'print' the HTML page as a pdf.

20. CTRL + SHIFT + M gives the pipe operator.

21. Pressing CTRL + F3 searches on the selected word.

22. CTRL

23. ALT + SHIFT + DOWN copies a line to below.

24. CTRL + ALT + K highlights all similar words in block for editing.
-->
```
<!-- ---?--- How do I create a closeable Rmd section, such that I do not have to scroll through the LaTeX commands each time? - !!! Can be done with '-----' through this also creates a line in the knittet document. -->

<!-- How do I publish and share the HTML as a viewable (and linkable) website - this can be done through github? -->

<!-- How can I share R markdown files such that multiple people can edit them at the same time? -->

<!-- Do we need parindent controls as in LaTeX? -->

<!-- Use of the cache function to reduce recompile times -->

<!-- How to close current subsection with a keyboard shortcut? How to close subsubsections,...? - !!!See RMD tip 14!!! -->

<!-- Chunk naming? -->

<!-- How to define variables such that they have scope within their own ## segment? -->

<!-- How do I delete all non-needed variables for each new section in R??? -->

<!-- LaTeX commands -->

\newcommand{\C}{\mathbb{C}}

<!--- Komplekse tal --->

\newcommand{\R}{\mathbb{R}}

<!--- Reelle tal--->

\newcommand{\Q}{\mathbb{Q}}

<!---Rationelle tal--->

\newcommand{\Z}{\mathbb{Z}}

<!---Hele tal--->

\newcommand{\N}{\mathbb{N}}

<!---Naturlige tal--->

\newcommand{\E}{\mathbb{E}}

<!---mean--->

\newcommand{\F}{\mathbb{F}}

<!---Baggrundsrum sigma-alg--->

\newcommand{\B}{\mathbb{B}}

<!---Borel sigma--->

\newcommand{\K}{\mathbb{K}}

<!---Generel field--->

\newcommand{\RB}{\overline{\R}}

<!---Udvidede reelle tal--->

\newcommand{\ms}[1]{\mathscr{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\BR}{\mathcal{B}\left(\R\right)}

<!---Borel på Reelle tal -->

\newcommand{\BRB}{\mathcal{B}\left(\RB\right))}

<!---Borel på udvidede reelle tal -->


\newcommand{\mf}[1]{\mathfrak{#1}} 
\newcommand{\mcG}[2]{\mathcal{#1}^1(#2)} 
\newcommand{\mcGG}[4]{\mathcal{#1}_{#3}^{#2}(#4)}
\newcommand{\GMR}{\left(X,\ms{A},\mu\right)}

<!---Generelt målrum -->

\newcommand{\PBS}{\lrp{\Omega,\F, P}}

<!--- Probability background space -->

\newcommand{\RMR}{\left(\R,\BR, \lambda\right)}

<!---Reelt målrum, m. Borel, og lebesgue mål. -->

<!---L_p spaces on [0,1] with m -->


\newcommand{\Lp}[1]{L_{#1}\lrp{\lrs{0,1},m}} 
\newcommand{\mclxy}{\mc{L}\lrp{X,Y}}
<!---Bounded linear functionals from X to Y -->

\newcommand{\mckxy}{\mc{K}\lrp{X,Y}}

<!---Compact Bounded linear functionals from X to Y -->

\newcommand{\mssr}{\ms{S}(\R)}

<!---The Schwartz space on $\R$ -->

<!---Arrows -->

\newcommand{\ra}{\rightarrow}

<!---Konvergens pil højre -->

\newcommand{\nra}{\nrightarrow}

<!---ikke Konvergens pil højre -->

\newcommand{\la}{\leftarrow}

<!---Konv pil venstre -->

\newcommand{\nla}{\nleftarrow}

<!---ikke Konvergens pil venstre -->

\newcommand{\lra}{\leftrightarrow}

<!---højre venstre pil -->

\newcommand{\nlra}{\nleftrightarrow}

<!---ikke højre venstre pil -->

\newcommand{\hra}{\hookrightarrow}

<!---Injektiv  pil højre -->

\newcommand{\Ra}{\Rightarrow}

<!---Implikations pil højre -->

\newcommand{\Lra}{\Leftrightarrow}

<!---Bi-implikations pil -->

\newcommand{\Uda}{\Updownarrow}

<!---Bi-implikations pil (op og ned) -->

\newcommand{\Da}{\Downarrow}

<!---implikations pil (ned) -->

\newcommand{\rhpu}{\rightharpoonup}

<!---Weak convergence in Hilbert spaces -->

<!-- LHS & RHS calculations -->

\newcommand{\swel}{\overset{\swarrow}{=}}

<!---Continue calculation on left hand side with equality -->

\newcommand{\sweq}{\overset{\swarrow}{\equiv}}

<!---Continue calculation on left hand side with equivalence -->

\newcommand{\seel}{\overset{\searrow}{=}}

<!---Continue calculation on right hand side with equality -->

\newcommand{\seeq}{\overset{\searrow}{\equiv}}

<!---Continue calculation on right hand side with equivalence -->

\newcommand{\inse}{\overset{\cdot}{=}}

<!--- Insert values in calculation -->

\newcommand{\eqd}{\overset{d.}{=}}

\newcommand{\PMX}{\mc{P}\left(X\right)}

<!---Potensmængde af X -->

\newcommand{\comp}{\mathsf{c}}

<!---Set compliment -->

\newcommand{\sm}{\setminus}

<!---mængdedifferens -->

<!--- Parenteser --->

\newcommand{\lrp}[1]{\mathopen{}\left({#1}\right)\mathclose{}}

<!-- \left("STUFF"\right) -->

\newcommand{\lrc}[1]{\mathopen{}\left\{{#1}\right\}\mathclose{}}

<!-- \left\{"STUFF"\right\} -->

\newcommand{\lrs}[1]{\mathopen{}\left[{#1}\right]\mathclose{}}

<!-- \left["STUFF"\right] -->

\newcommand{\lrb}[1]{\mathopen{}\left|{#1}\right|\mathclose{}}

<!-- \left|"STUFF"\right| -->

\newcommand{\inner}[2]{\mathopen{}\left\langle #1, #2 \right\rangle\mathclose{}}

<!-- <\left"STUFF1","STUFF2"\right> -->

\newcommand{\norm}[1]{\mathopen{}\left\lVert#1\right\rVert\mathclose{}}

<!-- \left||"STUFF"\right|| -->

\newcommand{\floor}[1]{\lfloor #1 \rfloor}

<!---Floor function --->

\newcommand{\ceil}[1]{\lceil #1 \rceil}

<!---ceil --->

\newcommand{\FFou}[1]{\mc{F}(#1)}

<!---Fourier Transform notation 1 --->

\newcommand{\Fou}[1]{\widehat{#1}}

<!---Fourier Transform notation 2 --->

<!--- Farver --->

\newcommand{\blue}[1]{\textcolor{blue}{{#1}}}

<!--- Turning text blue --->

\newcommand{\red}[1]{\textcolor{red}{{#1}}}

<!--- Turning text red --->

\newcommand{\green}[1]{\textcolor{green}{{#1}}}

<!--- Turning text green --->

\newcommand{\purple}[1]{\textcolor{purple}{{#1}}}

<!--- Turning text purple --->

\newcommand{\cyan}[1]{\textcolor{cyan}{{#1}}}

<!--- Turning text cyan --->

\newcommand{\orange}[1]{\textcolor{orange}{{#1}}}

<!--- Turning text orange --->

<!--- Oversetting bold accents --->


\newcommand{\boldhat}[1]{\mathbf{\hat{\text{$#1$}}}}
\newcommand{\boldbar}[1]{\mathbf{\bar{\text{$#1$}}}}
\newcommand{\boldtilde}[1]{\mathbf{\tilde{\text{$#1$}}}}
\newcommand{\boldcheck}[1]{\mathbf{\check{\text{$#1$}}}}
\newcommand{\indep}{\perp \!\!\! \perp}

<!---independence --->

\newcommand{\colvec}[1]{\begin{pmatrix}{#1}\end{pmatrix}}

<!-- Begin column vector - Doesn't seem to work with non-column vectors...-->

\newcommand{\nd}[2]{\mc{N}\lrp{{#1},{#2}}}

<!-- Normal distribution -->

\newcommand{\dnd}[2]{\sim\mc{N}\lrp{{#1},{#2}}}

<!-- Distributed as Normal distribution -->

\newcommand{\wnd}[3]{\frac{1}{\sqrt{2\pi\cdot {#3}}}e^{-\frac{1}{2}\frac{\lrp{{#1}-{#2}}^2}{{#3}}}}

<!-- With normal density (prob = #1, mean = #2, variance = #3 -->

\newcommand{\wpd}[2]{\frac{{#2}^{{#1}}\cdot e^{-{#2}}}{{#1}\!}}

<!-- With poisson density (prob = #1, mean = #2 -->

\newcommand{\ep}{\varepsilon}

<!-- \newcommand{\Rlogo}{![](../Data/R_logo.png){#id .class width=auto height=16px} } <!-- R logo implemented in text -->

<!-- Image insertion alla LaTeX doesn't seem to work too well..., but inserting the above gives the desired effect. -->

<!--???? \declareMathOperator{\SE}{SE} DOESN'T REALLY SEEM TO WORK????-->

<!-- #librar(reshape2) -->

<!-- #librar(lattice) -->

<!-- #librar(hebin) -->

<!-- #librar(xtable) -->

<!-- #librar(splines) -->

<!-- #librar(survival) -->

<!-- #librar(grid) -->

<!-- #librar(lpSolve) -->

<!-- #librar(unit) -->

<!-- #librar(MASS) #NOTE THAT MASS CAN CAUSE CONFLICTS WITH DPLYR OVER SELECT-FUNCTION -->




<!-- # !!!dplyr::select(indNoNA, where(is.numeric)) -->
<!-- indNoNA <- indians %>% drop_na() %>% mutate(across(c(pregnant:insulin,age), as.integer)) -->
<!-- install.packages("ggrepel") -->
<!-- !!! ```{r} -->
<!-- gdf <- -->
<!--   tibble(g = c(1, 1, 2, 3), v1 = 10:13, v2 = 20:23) %>% -->
<!--   group_by(g) -->
<!-- gdf -->

<!-- set.seed(1) -->

<!-- # Outside: 1 normal variate -->
<!-- n <- rnorm(1) -->
<!-- n -->
<!-- gdf %>% mutate(across(v1:v2, ~ .x + n)) -->
<!-- ``` -->

<!-- !!! ```{r} -->
<!-- ? family -->
<!-- ``` -->

<!-- !!! # ```{r} -->
<!-- # ifelse -->
<!-- # ``` -->

<!-- # ```{r} -->
<!-- # df <- df %>% -->
<!-- #   mutate(n = row_number()) %>% #create row number if you dont have one -->
<!-- #   select(n, everything()) # put 'n' at the front of the dataset -->
<!-- # train <- df %>% -->
<!-- #   group_by(var1, var2) %>% #any number of variables you wish to partition by proportionally -->
<!-- #   sample_frac(.7) # '.7' is the proportion of the original df you wish to sample -->
<!-- # test <- anti_join(df, train) # creates test dataframe with those observations not in 'train.' -->
<!-- # ``` -->


<!-- ```{r} -->
<!-- RColorBrewer::brewer.pal(10, "Set1") #but then try with 9 -->
<!-- ``` -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(fig.align = 'center')
library(tidyverse)
library(gridExtra)
theme_set(theme_minimal())
library(MASS) #Has a conflict with dplyr regarding select.
library(reshape2)
library(caret) #Used for Machine Learning
#library(plot.matrix) 
library(Matrix)
library(expm)
#library(plotly) #for 3D plotting
#library(reticulate) #Used for saving plotly images
#library(nloptr) #optimisation
#library(lpSolve) #linear programming
library(microbenchmark)
library(scales) #used for log trans of ggplot
#library(stats4) #mle and stuff
set.seed(314)

varnametotext <- function(v){
   deparse(substitute(v))
}
Stdresplot <- function(model, main = paste("(Estimate, Std. Res.)-plot of", deparse(substitute(model))), ylab ="Standardized residuals", ...) {
 fit <- fitted(model)
 rst <- rstandard(model)
 qplot(fit, rst, main = main, ylab = ylab, ylim = c(-max(3.2,max(abs(rst))), max(3.2,max(abs(rst)))) )+geom_hline(yintercept = 0) #Largest symmetric interval (around 0) of (-3.2,3.2) or (-largest absolute rst, largest absolute rst)
}
QQplotdraw <- function(model, main = paste("Normal QQ-plot of", deparse(substitute(model))), xlab = "Theoretical Quantiles", ylab ="Sample Quantiles", ...) {
   rst <- rstandard(model)
   #dataname <- getCall(lm_LT)$data
   ggplot(data = eval(getCall(model)$data), main = main, xlab = xlab, ylab = ylab) + geom_qq() + geom_qq_line() + aes(sample = rst)
} #main, xlab, ylab call do not work for some reason
StdresQQPlot <- function(model,...) {
   p1 <- Stdresplot(model,...)
   p2 <- QQplotdraw(model,...)
   #library(gridExtra)
   grid.arrange(p1,p2, ncol = 2)
}
```



# 1
There are a number of different methods that might be employed to estimate the integral of $f\lrp{x} := x^3\cdot\sin{\lrp{\frac{x+3.4}{2}}}$ using Monte Carlo-esque methods. One method would be to heed that $\sin{y}\in\lrs{-1,1},\, y \in \R$ while $y^3\in\lrs{0,27},\,y\in\lrs{0,3}.$ Thus, one could, borrowing terminology from point process theory, simulate a marked point process $U_1,\ldots,U_N\overset{\text{iid}}{\sim}\text{unif}\lrp{0,3},\,X_1,\ldots,X_N\overset{\text{iid}}{\sim} \text{unif}\lrp{-27,27}$ such that for $Z_1:= U_1 \times X_1, \ldots, Z_N := U_N \times X_N,\,\, N\gg 1,$ we might calculate the proportion of the $Z_i$ simulated points, that lie between the graph of $f$ and the abscissas, subtracting from the positive outcomes of $X,$ the negative, that satisfy the graph condition. Knowing that $m_{\otimes 2}\lrp{\lrs{0,3}\times\lrs{-27,27}} = 162$ we may multiply this \'block area\' with the proportion to estimate the area under the curve.

Such a solution may be implemented with $N=10^5$ as below.
```{r}
N <- 10^5
U <- runif(N, 0, 3)
X <- runif(N, -27, 27)
blockArea <- (3-0)*(27-(-27))
f <- function(u) {
   return(u^3*sin((u+3.4)/(2)))
}
fU <- f(U) #The estimated graph

#The positive resp. negative points of X that lie between the graph and the abscissas.
Xp <- X<=fU & X >= 0
Xn <- X>=fU & X<0

#The estimated area, and the integration using R as a comparison.
mean(Xp-Xn)*blockArea
integrate(f, 0, 3)[[1]]
```


A more direct utilising of LLN's, would be to simply simulate the $U_1, \ldots, U_N \overset{\text{iid}}{\sim}\text{unif}\lrp{0,3}$ and then take the average of the map these using $f,$ and multiply by the length of the interval. Such a solution may be seen implemented with $N=10^5$ as
```{r}
N <- 10^5
U <- runif(N, 0, 3)
f <- function(u) {
   return(u^3*sin((u+3.4)/(2)))
}

fU <- f(U) #The estimated graph
mean(fU)*3 #The estimated area under the curve
integrate(f, 0, 3)[[1]]
```

We note that two methods in essence act similarly, and can be seen to work based either on the framework of LLN's, or regular mathematical analysis-styled integral approximation.


#2.

Using previous work, we may write a function to simulate GBM's like so
```{r}
GBMSim1D <- function(Tf, dt, d, S0, mu, sigma) {
   #Simulates d 1D approximations to 1D geometric Brownian motions,
   #based on dynamics of the process that are governed by
   #dS_t = mu*S_t*dt + sigma*S_t*dW_t, for W_t being a Wiener process, 
   #from 0 until Tf.
   N <- Tf/dt
   
   #Initialisation
   Wd <- matrix(rep(0,(N+1)*d), nrow = N+1, ncol = d)

   #Calculate the pertubations
   for (j in 1:d) { #The column mechanic could also be achieved with apply.
      noisej <- rnorm(N, mean = 0, sd = sqrt(Tf/N)) 
      for (i in 1:N) {
         #Iterative simulation of BM by use of defining properties.
         Wd[i+1, j] <- Wd[i, j] + noisej[i]  
      }
   }
   
   S <- matrix(rep(S0,(N+1)*d), nrow = N+1, ncol = d) # Initialise S
   for (i in 1:N) {
      #Calculate S
      S[i+1, ] <- S[i,] + S[i, ]*(mu*dt+sigma*(Wd[i+1, ]-Wd[i,]))
   }
   return(S)
}
```


Noting that we have foregone the $dW_t^2 = dt$ modulated by noise approximation.

We may simulate five different trajectories with the requested volatility parameters.
Note that the requested $dt$ of $1$ iteration a day throughout a year will provide a terrible approximation of a true continuous geometric Brownian motion, and we should preferable have on the order of $100$ iterations between days, in order to get a sufficient approximation. 
```{r}
Tf <- 90
S0 <- 100 # Starting stock price
mu <- 0.05 # Stock drift rate per year
dt <- 1/365
sigma <- c(0.1, 0.25, 0.5, 0.75, 1) # volatility
strike <- 105 # strike price of call option
knock_out <- 130

sim1 <- data.frame(S = GBMSim1D(Tf = Tf, dt = dt, d = 1, S0 = S0, mu = mu, sigma = sigma[1])[1:91])
sim2 <- data.frame(S = GBMSim1D(Tf = Tf, dt = dt, d = 1, S0 = S0, mu = mu, sigma = sigma[2])[1:91])
sim3 <- data.frame(S = GBMSim1D(Tf = Tf, dt = dt, d = 1, S0 = S0, mu = mu, sigma = sigma[3])[1:91])
sim4 <- data.frame(S = GBMSim1D(Tf = Tf, dt = dt, d = 1, S0 = S0, mu = mu, sigma = sigma[4])[1:91])
sim5 <- data.frame(S = GBMSim1D(Tf = Tf, dt = dt, d = 1, S0 = S0, mu = mu, sigma = sigma[5])[1:91])

df <- bind_cols(S = bind_rows(sim1, sim2, sim3, sim4, sim5), t = rep(0:90, 5), simulation = c(rep("sigma0.1", 91), rep("sigma0.25", 91), rep("sigma0.5", 91), rep("sigma0.75", 91), rep("sigma1", 91)))

df %>% ggplot(mapping = aes(x = t, y = S, colour = simulation)) + geom_line(size = 1) + labs(title = "Five \"geometric Brownian motion trajectories\" of varying volatility", x = "Days", y = "Stock price") + scale_colour_discrete(name = "Volativity", labels = c("sigma = 0.1", "sigma = 0.25", "sigma = 0.5", "sigma = 0.75", "sigma = 1"))
```


We may use these simulations to calculate payoff with the knock-out-function:
```{r}
KOcheck <- function(v, knock_out) {
   #Returns 1 if there has been a knockout, 0 if there has not been a knock out.
   if(sum(v>=knock_out)>0) {
      return(1)
   } else {
      return(0)
   }
}

KOPayoff <- function(Tf, dt, d, S0, mu, sigma, strike, knock_out) { 
   #Calculates payout.
   S <- GBMSim1D(Tf, dt, d, S0, mu, sigma)[1:(Tf+1),]
   KOs <- apply(S, 2, KOcheck, knock_out = knock_out)
   payoff <- rep(NA, d)
   for (i in 1:d) {
      payoff[i] <- (1-KOs[i])*max(S[Tf+1,i]-strike, 0)
   }
   return(payoff)
}
```


We may calculate the payoff and the mean gain of the option.
```{r}
payoff <- KOPayoff(Tf = Tf, dt = dt, d = 1000, S0 = S0, mu = mu, sigma = sigma[3], strike = 105, knock_out = 130)
mean(payoff)
```
We may compare to the regular option
```{r}
ndays <- 90
S0 <- 100 # Starting stock price
mu <- 0.05 # Stock drift rate per year
dT <- 1/365
sigma <- 0.5 # volatility
strike <- 105 # strike price of call option
# Draw some normal random numbers ~ N(0,1)
niters <- 1000 # Number of Monte carlo simulations to do

option.payoff.arr <- c()

stock.prices <- list()
S90 <- c()
for (j in 1:niters) {
   N <- rnorm(ndays)
   S <- S0
   S_arr <- c(S0)
   for(i in 1:ndays) {
      dS <- S*(mu*dT + sigma*sqrt(dT)*N[i])
      S <- S + dS
      S_arr <- c(S_arr, S)
   }

   S90 <- c(S90, S)
   stock.prices[[j]] <- S_arr

   # For a call option, if the stock price at expiry is
   # higher than strike price, then we profit
   # Otherwise, we don't exercise the option
   option.payoff = max(S-strike,0)
   option.payoff.arr <- c(option.payoff.arr, option.payoff)
}
mean(option.payoff.arr)
```
We thus decide that the KO option is 
```{r}
mean(option.payoff.arr) - mean(payoff)
```
cheaper.

We may plot the two payoffs:
```{r}
d <- 1000
payoff_compare <- data.frame(payoff = bind_rows(data.frame(payoff = option.payoff.arr), data.frame(payoff = payoff)), type = c(rep("regular", d), rep("KO", d)))

payoff_compare %>% ggplot(aes(x = type, y = payoff, fill = type)) + geom_boxplot() + labs(title = "comparison of payoff of options")
```


#3 












